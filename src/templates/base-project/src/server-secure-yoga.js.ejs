import 'dotenv/config';
import { createServer } from 'node:http';
import { createYoga } from 'graphql-yoga';
import mongoose from 'mongoose';
import { makeExecutableSchema } from '@graphql-tools/schema';
import { typeDefs } from './graphql/typeDefs/index.js';
import resolvers from './graphql/resolvers/index.js';
import connectDB from './db/connection.js';
import { authenticateGraphQL } from './middleware/auth.js';
import { apiLimiter } from './middleware/rateLimiter.js';
import { securityPlugin, handleCORS, applySecurityHeaders } from './middleware/security.js';

const port = process.env.PORT || 4000;
const nodeEnv = process.env.NODE_ENV || 'development';

/**
 * Starts the GraphQL Yoga server with full security features
 */
async function start() {
  try {
    console.log(`\n🔧 Starting <%= projectName %> server in ${nodeEnv} mode...`);
    console.log('🔐 Security features enabled');

    // Connect to MongoDB
    await connectDB();

    // Create executable schema
    const schema = makeExecutableSchema({
      typeDefs,
      resolvers,
    });

    // Create Yoga instance with security plugins
    const yoga = createYoga({
      schema,
      context: ({ request }) => {
        // Base context
        const baseContext = {
          ip: request.headers.get('x-forwarded-for')?.split(',')[0] ||
             request.headers.get('x-real-ip') ||
             'unknown',
          userAgent: request.headers.get('user-agent'),
          request,
        };

        // Add authentication to context
        return authenticateGraphQL(baseContext);
      },

      // GraphiQL only in development
      graphiql: nodeEnv !== 'production',

      // Logging
      logging: {
        debug: nodeEnv === 'development' ? console.debug : () => {},
        info: console.info,
        warn: console.warn,
        error: console.error,
      },

      // Mask errors in production
      maskedErrors: nodeEnv === 'production',

      // Plugins
      plugins: [
        // Security headers plugin
        securityPlugin,

        // Rate limiting plugin
        {
          onExecute: ({ args }) => {
            const context = args.contextValue;

            // Apply appropriate rate limiter based on authentication
            const limiterType = context.isAuthenticated ? 'authenticated' : 'api';
            const result = limiterType === 'authenticated'
              ? apiLimiter.check(context)
              : apiLimiter.check(context);

            if (!result.allowed) {
              const error = new Error('Too many requests, please try again later');
              error.extensions = {
                code: 'RATE_LIMIT_EXCEEDED',
                limit: result.limit,
                remaining: 0,
                resetTime: result.resetTime,
              };
              throw error;
            }

            // Add rate limit info to context
            context.rateLimit = result;
          },
        },

        // Request logging plugin (development only)
        ...(nodeEnv === 'development'
          ? [
              {
                onExecute: ({ args }) => {
                  console.log('[GraphQL Request]', {
                    operation: args.operationName,
                    user: args.contextValue.user?.email || 'anonymous',
                    ip: args.contextValue.ip,
                  });
                },
              },
            ]
          : []),
      ],
    });

    // Create HTTP server
    const server = createServer((req, res) => {
      // Handle CORS
      if (handleCORS(req, res)) {
        return; // Request was handled (OPTIONS)
      }

      // Health check endpoint
      if (req.url === '/health' && req.method === 'GET') {
        const healthData = {
          status: 'ok',
          timestamp: new Date().toISOString(),
          uptime: process.uptime(),
          mongodb: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
          environment: nodeEnv,
          version: process.env.npm_package_version || '1.0.0',
        };

        res.setHeader('Content-Type', 'application/json');
        applySecurityHeaders(res, nodeEnv);
        res.statusCode = 200;
        res.end(JSON.stringify(healthData));
        return;
      }

      // Security info endpoint (development only)
      if (req.url === '/security' && req.method === 'GET' && nodeEnv === 'development') {
        const securityInfo = {
          rateLimit: {
            enabled: true,
            window: '15 minutes',
            limits: {
              anonymous: '100 requests',
              authenticated: '1000 requests',
              auth_endpoints: '5 requests',
            },
          },
          authentication: {
            type: 'JWT',
            accessTokenExpiry: process.env.ACCESS_TOKEN_EXPIRY || '15m',
            refreshTokenExpiry: process.env.REFRESH_TOKEN_EXPIRY || '7d',
          },
          cors: {
            enabled: true,
            allowedOrigins: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
          },
          headers: {
            csp: 'enabled',
            hsts: 'enabled',
            xssProtection: 'enabled',
          },
          features: [
            'JWT Authentication',
            'Role-Based Access Control',
            'Rate Limiting',
            'Audit Logging',
            'Input Sanitization',
            'XSS Protection',
            'CSRF Protection',
            'Security Headers',
          ],
        };

        res.setHeader('Content-Type', 'application/json');
        applySecurityHeaders(res, nodeEnv);
        res.statusCode = 200;
        res.end(JSON.stringify(securityInfo, null, 2));
        return;
      }

      // Handle GraphQL requests
      yoga(req, res);
    });

    // Start server
    server.listen(port, () => {
      console.log(`\n🚀 Server ready!`);
      console.log(`   GraphQL endpoint:  http://localhost:${port}/graphql`);
      console.log(`   Health check:      http://localhost:${port}/health`);
      console.log(`   Environment:       ${nodeEnv}`);

      if (nodeEnv === 'development') {
        console.log(`   Security info:     http://localhost:${port}/security`);
        console.log(`\n🔐 Security Features:`);
        console.log(`   ✓ JWT Authentication`);
        console.log(`   ✓ Role-Based Access Control`);
        console.log(`   ✓ Rate Limiting`);
        console.log(`   ✓ Input Sanitization`);
        console.log(`   ✓ Audit Logging`);
        console.log(`   ✓ Security Headers`);
      }

      console.log(`\n💡 Press Ctrl+C to stop\n`);
    });

    // Graceful shutdown
    const shutdown = async (signal) => {
      console.log(`\n\n⚠️  ${signal} received, shutting down gracefully...`);

      server.close(async () => {
        console.log('✅ HTTP server closed');

        try {
          await mongoose.connection.close();
          console.log('✅ MongoDB connection closed');
          process.exit(0);
        } catch (err) {
          console.error('❌ Error during shutdown:', err);
          process.exit(1);
        }
      });

      // Force shutdown after 10 seconds
      setTimeout(() => {
        console.error('❌ Forced shutdown after timeout');
        process.exit(1);
      }, 10000);
    };

    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('SIGINT', () => shutdown('SIGINT'));

    // Handle uncaught exceptions
    process.on('uncaughtException', (error) => {
      console.error('Uncaught Exception:', error);
      shutdown('UNCAUGHT_EXCEPTION');
    });

    process.on('unhandledRejection', (reason, promise) => {
      console.error('Unhandled Rejection at:', promise, 'reason:', reason);
      shutdown('UNHANDLED_REJECTION');
    });
  } catch (error) {
    console.error('\n❌ Failed to start server:', error.message);
    console.error(error);
    process.exit(1);
  }
}

start().catch((error) => {
  console.error('Startup error:', error);
  process.exit(1);
});
